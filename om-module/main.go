package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/Parz1val02/OM_module/dashboards"
	"github.com/Parz1val02/OM_module/discovery"
	"github.com/Parz1val02/OM_module/logging"
	"github.com/Parz1val02/OM_module/metrics"
)

var debugMode bool
var loggingService *logging.LoggingService

func main() {
	log.Printf("üöÄ Starting O&M Module for 4G/5G Educational Network Testbed")

	// Parse command line arguments
	mode := "discovery"
	envFile := "../.env"

	// Detect if running in Docker and adjust env file path
	if isRunningInDocker() {
		envFile = ".env"
		log.Printf("üê≥ Running in Docker environment")
	}

	if len(os.Args) > 1 {
		mode = os.Args[1]
	}
	if len(os.Args) > 2 {
		if os.Args[2] == "--debug" {
			debugMode = true
			log.Printf("üêû Debug mode enabled")
		} else {
			envFile = os.Args[2]
		}
	}

	switch mode {
	case "orchestrator":
		runRealMetricsOrchestrator(envFile)
	case "discovery":
		runDiscoveryMode(envFile)
	default:
		printBanner()
		printUsage()
		os.Exit(1)
	}
}

// Detect if running in Docker environment
func isRunningInDocker() bool {
	if _, err := os.Stat("/.dockerenv"); err == nil {
		return true
	}
	return false
}

// Real-time metrics orchestrator mode - Live monitoring and collection
func runRealMetricsOrchestrator(envFile string) {
	printBanner()
	printOrchestratorModeDescription()

	// Detect environment
	inDocker := isRunningInDocker()
	if inDocker {
		log.Printf("üê≥ Docker environment detected - using Docker networking")
	}

	// Create discovery service
	discoveryService, err := discovery.NewAutoDiscoveryService(envFile)
	if err != nil {
		log.Fatalf("‚ùå Failed to create discovery service: %v", err)
	}
	defer func() {
		err = discoveryService.Close()
	}()

	// Create context for all operations
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Discover topology first
	log.Printf("üîÑ Discovering network topology...")
	topology, err := discoveryService.DiscoverTopology(ctx)
	if err != nil {
		log.Fatalf("‚ùå Failed to discover topology: %v", err)
	}

	log.Printf("üîÑ Initializing real-time metrics collection system...")

	// Create real collector orchestrator
	orchestrator := metrics.NewRealCollectorOrchestrator(discoveryService)

	// Start the real Open5GS orchestrator
	if err := orchestrator.Start(); err != nil {
		log.Fatalf("‚ùå Failed to start real metrics orchestrator: %v", err)
	}

	// NEW: Initialize and start logging service
	log.Printf("üìù Initializing dynamic logging pipeline...")
	if err := initializeLoggingService(topology); err != nil {
		log.Printf("‚ö†Ô∏è Failed to initialize logging service: %v", err)
		// Continue without logging service - don't fail the entire application
	} else {
		log.Printf("‚úÖ Logging pipeline initialized successfully")
	}

	// Start infrastructure collectors
	log.Printf("üîÑ Starting infrastructure collectors...")

	// Start container metrics collector
	containerCollector, err := metrics.NewContainerMetricsCollector(8080)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to create container collector: %v", err)
	} else {
		go func() {
			if err := containerCollector.Start(ctx, topology); err != nil && err != context.Canceled {
				log.Printf("‚ùå Container collector error: %v", err)
			}
		}()
		log.Printf("üü¢ Started container metrics collector on :8080")
	}

	// Start health check collector
	healthCollector := metrics.NewHealthCheckCollector(8081)
	go func() {
		if err := healthCollector.Start(ctx, topology); err != nil && err != context.Canceled {
			log.Printf("‚ùå Health collector error: %v", err)
		}
	}()
	log.Printf("üü¢ Started health check collector on :8081")

	// Generate Docker-aware Prometheus configuration
	if err := generateDockerPrometheusConfig(orchestrator, topology, inDocker); err != nil {
		log.Printf("‚ö†Ô∏è Failed to generate Prometheus config: %v", err)
	}

	// Wait for collectors to be healthy
	log.Printf("‚è≥ Performing health checks on all collectors...")
	if err := orchestrator.WaitForHealthy(30 * time.Second); err != nil {
		log.Printf("‚ö†Ô∏è  Warning: Some collectors may not be fully ready: %v", err)
	}

	// Generate Grafana dashboards
	if err := dashboards.GenerateGrafanaDashboards(orchestrator, topology, inDocker); err != nil {
		log.Printf("‚ö†Ô∏è Failed to generate Grafana dashboards: %v", err)
	} else {
		log.Printf("‚úÖ Generated Grafana dashboards successfully")
	}

	// NEW: Start HTTP server for logging endpoints
	go startLoggingHTTPServer()

	// Display live status
	displayRealMetricsStatus(orchestrator)

	// Set up graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	log.Printf("üåü Orchestrator mode is now LIVE! All metrics are being collected in real-time.")
	log.Printf("üìä Access Prometheus metrics at the endpoints shown above")
	log.Printf("üìù Access logging service at http://localhost:8080/logging/*")
	if inDocker {
		log.Printf("üê≥ Docker mode: Prometheus config written to shared volume")
	}
	log.Printf("‚ö° Press Ctrl+C to stop the orchestrator...")

	// Wait for shutdown signal
	<-sigChan
	log.Printf("üõë Received shutdown signal, gracefully stopping all collectors...")

	// Cancel context to stop all collectors
	cancel()

	// Stop services
	orchestrator.Stop()
	cleanupLoggingService()

	// Give collectors time to stop gracefully
	time.Sleep(2 * time.Second)

	log.Printf("‚úÖ Real-time metrics orchestrator stopped cleanly")
}

// NEW: Initialize logging service
func initializeLoggingService(topology *discovery.NetworkTopology) error {
	log.Printf("üîß Initializing Logging Service...")

	// Load configuration from environment
	config := logging.LoadConfigFromEnv()

	// Create logging service
	loggingService = logging.NewLoggingService(topology, config)

	// Start the service
	if err := loggingService.Start(); err != nil {
		return fmt.Errorf("failed to start logging service: %w", err)
	}

	log.Printf("‚úÖ Logging Service initialized successfully")
	return nil
}

// NEW: Start HTTP server for logging endpoints
func startLoggingHTTPServer() {
	mux := http.NewServeMux()

	// Add logging endpoints
	addLoggingEndpoints(mux)

	// Start server on a separate port to avoid conflicts
	server := &http.Server{
		Addr:    ":8083", // Use port 8083 for logging HTTP endpoints
		Handler: mux,
	}

	log.Printf("üåê Logging HTTP server starting on :8083")
	if err := server.ListenAndServe(); err != nil {
		log.Printf("‚ö†Ô∏è Logging HTTP server error: %v", err)
	}
}

// NEW: Add logging endpoints to HTTP server
func addLoggingEndpoints(mux *http.ServeMux) {
	// Logging service endpoints
	mux.HandleFunc("/logging/status", handleLoggingStatus)
	mux.HandleFunc("/logging/configs", handlePromtailConfigs)
	mux.HandleFunc("/logging/health", handleLoggingHealth)
	mux.HandleFunc("/logging/dashboard", handleEducationalDashboard)

	// Educational endpoints
	mux.HandleFunc("/educational/insights", func(w http.ResponseWriter, r *http.Request) {
		topology := getCurrentTopology()
		insights := logging.GetEducationalInsights(topology)

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(insights); err != nil {
			log.Printf("‚ùå Log collector server error: %v", err)
		}
	})

	// Root endpoint for logging service
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		response := map[string]any{
			"service": "O&M Logging Service",
			"version": "1.0.0",
			"endpoints": []string{
				"/logging/status",
				"/logging/configs",
				"/logging/health",
				"/logging/dashboard",
				"/educational/insights",
			},
		}
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("‚ùå Log collector server error: %v", err)
		}
	})
}

// NEW: HTTP handlers for logging service

// handleLoggingStatus returns the status of the logging service
func handleLoggingStatus(w http.ResponseWriter, r *http.Request) {
	if loggingService == nil {
		http.Error(w, "Logging service not initialized", http.StatusServiceUnavailable)
		return
	}

	status := loggingService.GetStatus()

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(status); err != nil {
		http.Error(w, "Failed to encode status", http.StatusInternalServerError)
		return
	}
}

// handlePromtailConfigs returns the generated Promtail configurations
func handlePromtailConfigs(w http.ResponseWriter, r *http.Request) {
	if loggingService == nil {
		http.Error(w, "Logging service not initialized", http.StatusServiceUnavailable)
		return
	}

	configs, err := loggingService.GetPromtailConfigs()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to get configs: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(configs); err != nil {
		http.Error(w, "Failed to encode configs", http.StatusInternalServerError)
		return
	}
}

// handleEducationalDashboard returns educational content for students
func handleEducationalDashboard(w http.ResponseWriter, r *http.Request) {
	if loggingService == nil {
		http.Error(w, "Logging service not initialized", http.StatusServiceUnavailable)
		return
	}

	topology := getCurrentTopology()

	dashboard := logging.GenerateEducationalDashboard(topology)
	insights := logging.GetEducationalInsights(topology)

	response := map[string]any{
		"dashboard": dashboard,
		"insights":  insights,
		"timestamp": time.Now().Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, "Failed to encode dashboard", http.StatusInternalServerError)
		return
	}
}

// handleLoggingHealth provides health check for logging components
func handleLoggingHealth(w http.ResponseWriter, r *http.Request) {
	health := map[string]any{
		"timestamp": time.Now().Format(time.RFC3339),
		"status":    "healthy",
		"components": map[string]string{
			"loki":     "checking...",
			"parser":   "checking...",
			"promtail": "checking...",
		},
	}

	if loggingService != nil {
		status := loggingService.GetStatus()
		if running, ok := status["running"].(bool); ok && running {
			health["components"].(map[string]string)["logging_service"] = "healthy"
		} else {
			health["components"].(map[string]string)["logging_service"] = "stopped"
			health["status"] = "degraded"
		}
	} else {
		health["components"].(map[string]string)["logging_service"] = "not_initialized"
		health["status"] = "unhealthy"
	}

	// Check Loki connectivity
	go checkLokiHealth(health)

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(health); err != nil {
		log.Printf("‚ùå Log health server error: %v", err)
	}
}

// checkLokiHealth checks if Loki is accessible
func checkLokiHealth(health map[string]any) {
	lokiURL := os.Getenv("LOKI_URL")
	if lokiURL == "" {
		lokiURL = "http://loki:3100"
	}

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(lokiURL + "/ready")
	if err != nil {
		health["components"].(map[string]string)["loki"] = "unreachable"
		return
	}
	defer func() {
		err = resp.Body.Close()
	}()

	if resp.StatusCode == 200 {
		health["components"].(map[string]string)["loki"] = "healthy"
	} else {
		health["components"].(map[string]string)["loki"] = "unhealthy"
	}
}

// getCurrentTopology returns the current topology (you may need to adapt this)
func getCurrentTopology() *discovery.NetworkTopology {
	// For now, return nil - you may want to store the topology globally
	// or retrieve it from your discovery service
	return nil
}

// cleanupLoggingService should be called during application shutdown
func cleanupLoggingService() {
	if loggingService != nil {
		if err := loggingService.Stop(); err != nil {
			log.Printf("‚ö†Ô∏è Error stopping logging service: %v", err)
		}
	}
}

// updateTopologyInLoggingService updates the logging service when topology changes
func updateTopologyInLoggingService(newTopology *discovery.NetworkTopology) {
	if loggingService != nil {
		if err := loggingService.UpdateTopology(newTopology); err != nil {
			log.Printf("‚ö†Ô∏è Failed to update logging service topology: %v", err)
		}
	}
}

// Generate Docker-aware Prometheus configuration
func generateDockerPrometheusConfig(orchestrator *metrics.RealCollectorOrchestrator, topology *discovery.NetworkTopology, inDocker bool) error {
	configPath := "../prometheus/configs/prometheus.yml"
	if inDocker {
		configPath = "/etc/prometheus/configs/prometheus.yml"
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil && inDocker {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	var config strings.Builder

	// Global configuration
	config.WriteString("global:\n")
	config.WriteString("  scrape_interval: 5s\n")
	config.WriteString("  evaluation_interval: 5s\n")
	config.WriteString("  external_labels:\n")
	if inDocker {
		config.WriteString("    monitor: 'om-module-docker'\n")
	} else {
		config.WriteString("    monitor: 'om-module-standalone'\n")
	}
	if topology != nil {
		config.WriteString(fmt.Sprintf("    deployment_type: '%s'\n", topology.Type))
	}
	config.WriteString("\n")

	// Rule files
	config.WriteString("rule_files:\n")
	config.WriteString("  - 'rules/*.yml'\n")
	config.WriteString("\n")

	// Scrape configurations
	config.WriteString("scrape_configs:\n")

	// Real Open5GS metrics
	endpoints := orchestrator.GetMetricsEndpoints()
	if len(endpoints) > 0 {
		config.WriteString("  # Real Open5GS Network Function Endpoints\n")
		for componentName, endpoint := range endpoints {
			// Extract port from endpoint (e.g., http://localhost:9091/metrics -> 9091)
			port := extractPortFromEndpoint(endpoint)

			// Use Docker service name or localhost based on environment
			target := fmt.Sprintf("localhost:%s", port)
			if inDocker {
				target = fmt.Sprintf("om-module:%s", port)
			}

			config.WriteString(fmt.Sprintf("  - job_name: '%s-real'\n", componentName))
			config.WriteString("    scrape_interval: 5s\n")
			config.WriteString("    metrics_path: '/metrics'\n")
			config.WriteString("    static_configs:\n")
			config.WriteString(fmt.Sprintf("      - targets: ['%s']\n", target))
			config.WriteString("        labels:\n")
			config.WriteString(fmt.Sprintf("          component: '%s'\n", componentName))
			config.WriteString(fmt.Sprintf("          source: 'real_open5gs'\n"))
			if topology != nil {
				config.WriteString(fmt.Sprintf("          deployment: '%s'\n", topology.Type))
			}
			config.WriteString("\n")
		}
	}

	// Container metrics
	containerTarget := "localhost:8080"
	if inDocker {
		containerTarget = "om-module:8080"
	}

	config.WriteString("  # Container Resource Metrics\n")
	config.WriteString("  - job_name: 'container-metrics'\n")
	config.WriteString("    scrape_interval: 10s\n")
	config.WriteString("    metrics_path: '/container/metrics'\n")
	config.WriteString("    static_configs:\n")
	config.WriteString(fmt.Sprintf("      - targets: ['%s']\n", containerTarget))
	config.WriteString("        labels:\n")
	config.WriteString("          source: 'container_stats'\n")
	if topology != nil {
		config.WriteString(fmt.Sprintf("          deployment: '%s'\n", topology.Type))
	}
	config.WriteString("\n")

	// Health check metrics
	healthTarget := "localhost:8081"
	if inDocker {
		healthTarget = "om-module:8081"
	}

	config.WriteString("  # Component Health Checks\n")
	config.WriteString("  - job_name: 'health-checks'\n")
	config.WriteString("    scrape_interval: 15s\n")
	config.WriteString("    metrics_path: '/health/metrics'\n")
	config.WriteString("    static_configs:\n")
	config.WriteString(fmt.Sprintf("      - targets: ['%s']\n", healthTarget))
	config.WriteString("        labels:\n")
	config.WriteString("          source: 'health_check'\n")
	if topology != nil {
		config.WriteString(fmt.Sprintf("          deployment: '%s'\n", topology.Type))
	}
	config.WriteString("\n")

	// Write configuration
	if err := os.WriteFile(configPath, []byte(config.String()), 0644); err != nil {
		return fmt.Errorf("failed to write Prometheus config: %w", err)
	}

	log.Printf("üìÑ Generated Prometheus configuration: %s", configPath)

	// Reload Prometheus if running in Docker
	if inDocker {
		go reloadPrometheus()
	}

	return nil
}

// Extract port number from endpoint URL
func extractPortFromEndpoint(endpoint string) string {
	// Parse URL like "http://localhost:9091/metrics" -> "9091"
	parts := strings.Split(endpoint, ":")
	if len(parts) >= 3 {
		portPart := parts[2]
		return strings.Split(portPart, "/")[0]
	}
	return "9091" // default
}

// Reload Prometheus configuration
func reloadPrometheus() {
	time.Sleep(5 * time.Second) // Give Prometheus time to start and config to be written

	// Try to reload Prometheus configuration via Docker network
	metricsIP := os.Getenv("METRICS_IP")
	if metricsIP == "" {
		metricsIP = "prometheus" // Use Docker service name as fallback
	}

	reloadURL := fmt.Sprintf("http://%s:9090/-/reload", metricsIP)
	log.Printf("üîÑ Attempting to reload Prometheus config at: %s", reloadURL)

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Post(reloadURL, "", nil)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to reload Prometheus config: %v", err)
		return
	}
	defer func() {
		err = resp.Body.Close()
	}()

	if resp.StatusCode == 200 {
		log.Printf("‚úÖ Prometheus configuration reloaded successfully")
	} else {
		log.Printf("‚ö†Ô∏è Prometheus reload returned status: %d", resp.StatusCode)
	}
}

// Discovery mode - Static analysis and configuration generation
func runDiscoveryMode(envFile string) {
	printBanner()
	printDiscoveryModeDescription()

	// Create discovery service
	discoveryService, err := discovery.NewAutoDiscoveryService(envFile)
	if err != nil {
		log.Fatalf("‚ùå Failed to create discovery service: %v", err)
	}
	defer func() {
		err = discoveryService.Close()
	}()

	// Create context with timeout for discovery operations
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	log.Printf("üîç Step 1: Analyzing Docker containers and network topology...")

	// Discover topology
	topology, err := discoveryService.DiscoverTopology(ctx)
	if err != nil {
		log.Fatalf("‚ùå Failed to discover topology: %v", err)
	}

	log.Printf("‚úÖ Step 1 Complete: Found %d components in %s deployment",
		len(topology.Components), topology.Type)

	log.Printf("üîß Step 2: Generating static configuration files...")

	// Export topology and configuration files
	exportTopologyAndConfig(topology)

	log.Printf("‚úÖ Step 2 Complete: Configuration files generated")

	// NEW: Step 3 - Initialize logging service for configuration generation
	log.Printf("üìù Step 3: Generating dynamic logging configurations...")
	if err := initializeLoggingServiceForDiscovery(topology); err != nil {
		log.Printf("‚ö†Ô∏è Failed to generate logging configurations: %v", err)
	} else {
		log.Printf("‚úÖ Step 3 Complete: Logging configurations generated")

		// Generate educational content
		generateEducationalContent(topology)
	}

	// Display comprehensive discovery results
	displayDiscoveryResults(topology)

	// NEW: Display logging setup results
	displayLoggingResults()

	// Display next steps for real metrics
	printRealMetricsNextSteps()

	log.Printf("üéØ Discovery mode completed successfully!")
	log.Printf("üìÅ All configuration files are ready for use with Prometheus/Grafana")
	if isRunningInDocker() {
		log.Printf("üê≥ To start live monitoring: docker-compose restart om-module")
	} else {
		log.Printf("üöÄ To start live monitoring, run: ./om-module orchestrator")
	}
}

// NEW: Initialize logging service for discovery mode (config generation only)
func initializeLoggingServiceForDiscovery(topology *discovery.NetworkTopology) error {
	config := logging.LoadConfigFromEnv()

	// Create logging service but don't start log parser in discovery mode
	config.ParserEnabled = false

	tempLoggingService := logging.NewLoggingService(topology, config)

	// Generate configurations without starting the full service
	if err := tempLoggingService.Start(); err != nil {
		return fmt.Errorf("failed to generate logging configurations: %w", err)
	}

	// Stop the service after configuration generation
	if err := tempLoggingService.Stop(); err != nil {
		return fmt.Errorf("failed to stop logging configurations: %w", err)
	}

	return nil
}

// NEW: Generate educational content
func generateEducationalContent(topology *discovery.NetworkTopology) {
	// Generate educational dashboard
	dashboard := logging.GenerateEducationalDashboard(topology)
	if err := writeFile("educational_dashboard.md", dashboard); err != nil {
		log.Printf("‚ö†Ô∏è Failed to write educational dashboard: %v", err)
	} else {
		log.Printf("üìö Educational dashboard written to: educational_dashboard.md")
	}

	// Write logging insights
	insights := logging.GetEducationalInsights(topology)
	insightsJSON, _ := json.MarshalIndent(insights, "", "  ")
	if err := writeFile("logging_insights.json", string(insightsJSON)); err != nil {
		log.Printf("‚ö†Ô∏è Failed to write logging insights: %v", err)
	} else {
		log.Printf("üí° Logging insights written to: logging_insights.json")
	}
}

// NEW: Display logging setup results
func displayLoggingResults() {
	fmt.Printf("\nüìù LOGGING PIPELINE SETUP\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

	fmt.Printf("üöÄ Logging Configuration Status:\n")
	fmt.Printf("   ‚îú‚îÄ Promtail Configs: ‚úÖ Generated\n")
	fmt.Printf("   ‚îú‚îÄ Core Network: ./promtail/core/config.yml\n")
	fmt.Printf("   ‚îú‚îÄ RAN Components: ./promtail/ran/config.yml\n")
	fmt.Printf("   ‚îî‚îÄ Educational Mode: Enabled\n")

	fmt.Printf("\nüìÑ Generated Files:\n")
	fmt.Printf("   ‚îú‚îÄ educational_dashboard.md ‚Üí Student learning guide\n")
	fmt.Printf("   ‚îú‚îÄ logging_insights.json ‚Üí Protocol analysis insights\n")
	fmt.Printf("   ‚îú‚îÄ promtail/core/config.yml ‚Üí Core network log config\n")
	fmt.Printf("   ‚îî‚îÄ promtail/ran/config.yml ‚Üí RAN log config\n")

	fmt.Printf("\nüéì Educational Features:\n")
	fmt.Printf("   ‚îú‚îÄ Protocol-aware log parsing (NAS, RRC, S1AP)\n")
	fmt.Printf("   ‚îú‚îÄ 3GPP specification references\n")
	fmt.Printf("   ‚îú‚îÄ Session flow tracking with IMSI correlation\n")
	fmt.Printf("   ‚îú‚îÄ Performance metrics extraction (RSRP, RSRQ)\n")
	fmt.Printf("   ‚îî‚îÄ Troubleshooting guides and procedures\n")

	fmt.Printf("\nüîó Runtime Access Points:\n")
	fmt.Printf("   ‚îú‚îÄ Log Parser API: http://localhost:8082 (when running)\n")
	fmt.Printf("   ‚îú‚îÄ Loki API: http://localhost:3100\n")
	fmt.Printf("   ‚îú‚îÄ Grafana: http://localhost:3000\n")
	fmt.Printf("   ‚îî‚îÄ Logging Service: http://localhost:8083/logging/* (when running)\n")

	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
}

// Print clear description of what orchestrator mode does
func printOrchestratorModeDescription() {
	fmt.Printf("üé¨ ORCHESTRATOR MODE - Live Real-Time Metrics Collection\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
	fmt.Printf("This mode starts a LIVE metrics collection system that:\n\n")
	fmt.Printf("üîÑ Real-Time Operations:\n")
	fmt.Printf("   ‚Ä¢ Continuously monitors all Open5GS network functions\n")
	fmt.Printf("   ‚Ä¢ Collects live metrics directly from AMF, SMF, UPF, etc.\n")
	fmt.Printf("   ‚Ä¢ Gathers container resource usage (CPU, memory, I/O)\n")
	fmt.Printf("   ‚Ä¢ Performs health checks every 15 seconds\n")
	fmt.Printf("   ‚Ä¢ Automatically adapts to topology changes\n")
	fmt.Printf("   ‚Ä¢ Processes logs in real-time with educational context\n\n")
	fmt.Printf("üåê Active HTTP Endpoints:\n")
	fmt.Printf("   ‚Ä¢ Real Open5GS metrics: ports 9091-9096\n")
	fmt.Printf("   ‚Ä¢ Container metrics: port 8080\n")
	fmt.Printf("   ‚Ä¢ Health checks: port 8081\n")
	fmt.Printf("   ‚Ä¢ Log parser: port 8082\n")
	fmt.Printf("   ‚Ä¢ Logging service: port 8083\n")
	fmt.Printf("   ‚Ä¢ Educational dashboards and debug info\n\n")
	fmt.Printf("üìä Integration Ready:\n")
	fmt.Printf("   ‚Ä¢ Prometheus can scrape all endpoints immediately\n")
	fmt.Printf("   ‚Ä¢ Grafana dashboards show live data\n")
	fmt.Printf("   ‚Ä¢ Loki receives structured logs with educational metadata\n")
	fmt.Printf("   ‚Ä¢ Perfect for lab demonstrations and learning\n\n")
	if isRunningInDocker() {
		fmt.Printf("üê≥ Docker Mode:\n")
		fmt.Printf("   ‚Ä¢ Automatic Prometheus configuration\n")
		fmt.Printf("   ‚Ä¢ Docker network integration\n")
		fmt.Printf("   ‚Ä¢ Shared volume configuration\n\n")
	}
	fmt.Printf("‚ö†Ô∏è  Note: Requires running Open5GS containers with metrics enabled\n")
	fmt.Printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
}

// Print clear description of what discovery mode does
func printDiscoveryModeDescription() {
	fmt.Printf("üîç DISCOVERY MODE - Static Analysis & Configuration Generation\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
	fmt.Printf("This mode performs a comprehensive analysis of your testbed setup:\n\n")
	fmt.Printf("üîé Analysis Phase:\n")
	fmt.Printf("   ‚Ä¢ Scans Docker containers to identify network functions\n")
	fmt.Printf("   ‚Ä¢ Maps network topology (4G vs 5G components)\n")
	fmt.Printf("   ‚Ä¢ Determines which components support native metrics\n")
	fmt.Printf("   ‚Ä¢ Identifies container resource monitoring targets\n")
	fmt.Printf("   ‚Ä¢ Assesses health check capabilities\n")
	fmt.Printf("   ‚Ä¢ Analyzes log sources and formats\n\n")
	fmt.Printf("üìù Configuration Generation:\n")
	fmt.Printf("   ‚Ä¢ Creates Prometheus scrape configurations\n")
	fmt.Printf("   ‚Ä¢ Generates dynamic Promtail configurations\n")
	fmt.Printf("   ‚Ä¢ Builds comprehensive monitoring setup files\n")
	fmt.Printf("   ‚Ä¢ Prepares educational dashboard configurations\n")
	fmt.Printf("   ‚Ä¢ Creates protocol-aware log parsing rules\n\n")
	fmt.Printf("üìÅ Output Files Created:\n")
	fmt.Printf("   ‚Ä¢ prometheus_targets.yml - Ready-to-use Prometheus config\n")
	fmt.Printf("   ‚Ä¢ promtail/core/config.yml - Core network log configuration\n")
	fmt.Printf("   ‚Ä¢ promtail/ran/config.yml - RAN log configuration\n")
	fmt.Printf("   ‚Ä¢ topology.json - Machine-readable topology data\n")
	fmt.Printf("   ‚Ä¢ educational_dashboard.md - Student learning guide\n")
	fmt.Printf("   ‚Ä¢ logging_insights.json - Protocol analysis insights\n\n")
	fmt.Printf("üéØ Educational Benefits:\n")
	fmt.Printf("   ‚Ä¢ Students can see the complete monitoring architecture\n")
	fmt.Printf("   ‚Ä¢ Understand which components provide which metrics\n")
	fmt.Printf("   ‚Ä¢ Learn industry-standard observability practices\n")
	fmt.Printf("   ‚Ä¢ See protocol-specific log parsing configurations\n\n")
	fmt.Printf("‚ö†Ô∏è  Note: This mode does NOT start live collection - use 'orchestrator' for that\n")
	fmt.Printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
}

// Enhanced display for orchestrator mode with better categorization
func displayRealMetricsStatus(orchestrator *metrics.RealCollectorOrchestrator) {
	endpoints := orchestrator.GetMetricsEndpoints()
	status := orchestrator.GetStatus()

	// Optional debug dump
	if debugMode {
		if jsonBytes, err := json.MarshalIndent(status, "", "  "); err == nil {
			if err := os.WriteFile("status_debug.json", jsonBytes, 0644); err != nil {
				log.Printf("‚ö†Ô∏è  Failed to write status_debug.json: %v", err)
			} else {
				log.Printf("üêû Debug: status exported to status_debug.json")
			}
		} else {
			log.Printf("‚ö†Ô∏è  Failed to marshal status for debug: %v", err)
		}
	}

	fmt.Printf("\nüéØ LIVE METRICS COLLECTION STATUS\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

	// Real Open5GS collectors status
	if collectorsRoot, ok := status["collectors"].(map[string]any); ok {
		if collectors, ok := collectorsRoot["collectors"].(map[string]any); ok {
			fmt.Printf("üìä Active Collectors: %d\n\n", len(collectors))

			for componentName, info := range collectors {
				if collectorInfo, ok := info.(map[string]any); ok {
					// Extract fields with CORRECT field names from your JSON
					nfType, _ := collectorInfo["nf_type"].(string)
					componentIP, _ := collectorInfo["component_ip"].(string)
					fetchURL, _ := collectorInfo["fetch_url"].(string)
					// Fix 1: Handle collector_port properly
					collectorPort := "N/A"
					if port, ok := collectorInfo["collector_port"]; ok {
						// Handle both int and float64 types
						switch v := port.(type) {
						case float64:
							collectorPort = fmt.Sprintf("%.0f", v)
						case int:
							collectorPort = fmt.Sprintf("%d", v)
						case string:
							collectorPort = v
						default:
							collectorPort = fmt.Sprintf("%v", v)
						}
					}

					// Fix 2: Handle metrics_count properly
					metricsCount := 0
					if count, ok := collectorInfo["metrics_count"]; ok {
						switch v := count.(type) {
						case float64:
							metricsCount = int(v)
						case int:
							metricsCount = v
						default:
							if countStr := fmt.Sprintf("%v", v); countStr != "" {
								if parsed, err := strconv.Atoi(countStr); err == nil {
									metricsCount = parsed
								}
							}
						}
					}

					// Fix 3: Handle status properly
					isHealthy := false
					if statusBool, ok := collectorInfo["status"].(bool); ok {
						isHealthy = statusBool
					}

					healthIcon := "üü¢"
					healthText := "Healthy"
					if !isHealthy {
						healthIcon = "üî¥"
						healthText = "Unhealthy"
					}

					// Print detailed collector info with metrics count
					fmt.Printf("%s %s %s (%s) %s - %d metrics\n",
						healthIcon, healthText, componentName, strings.ToUpper(nfType), componentIP, int(metricsCount))
					if fetchURL != "" {
						fmt.Printf("   üì° Fetching from: %s\n", fetchURL)
					}

					// Show appropriate endpoint based on environment
					endpoint := fmt.Sprintf("http://localhost:%s", collectorPort)
					if isRunningInDocker() {
						fmt.Printf("   üìä Docker endpoint: http://om-module:%s/metrics\n", collectorPort)
						fmt.Printf("   üìä External access:  %s/metrics\n", endpoint)
					} else {
						fmt.Printf("   üìä Exposing at:   %s/metrics\n", endpoint)
					}

					fmt.Printf("   üè• Health check:  %s/health\n", endpoint)
					fmt.Printf("   üìö Dashboard:     %s/dashboard\n", endpoint)
					fmt.Printf("   üîç Raw data:      %s/debug/raw\n", endpoint)
					fmt.Printf("\n")
				}
			}
		} else {
			log.Printf("‚ö†Ô∏è No nested collectors found inside status[\"collectors\"]")
		}
	}

	fmt.Printf("üìä Infrastructure Metrics:\n")
	baseURL := "http://localhost"
	if isRunningInDocker() {
		fmt.Printf("   ‚îú‚îÄ Docker endpoints: http://om-module:8080 & http://om-module:8081\n")
	}
	fmt.Printf("   ‚îú‚îÄ Container Stats  üü¢ Active:\n")
	fmt.Printf("   ‚îÇ  ‚îú‚îÄ All containers: %s:8080/container/metrics\n", baseURL)
	fmt.Printf("   ‚îÇ  ‚îî‚îÄ Collector health: %s:8080/health\n", baseURL)
	fmt.Printf("   ‚îú‚îÄ Health Checks    üü¢ Active:\n")
	fmt.Printf("   ‚îÇ  ‚îú‚îÄ All components: %s:8081/health/metrics\n", baseURL)
	fmt.Printf("   ‚îÇ  ‚îî‚îÄ Collector health: %s:8081/health\n", baseURL)
	fmt.Printf("   ‚îî‚îÄ System Resources üü¢ Active ‚Üí Collected every 10s\n\n")

	// NEW: Display logging service status
	fmt.Printf("üìù Logging Service:\n")
	if loggingService != nil {
		loggingStatus := loggingService.GetStatus()
		if running, ok := loggingStatus["running"].(bool); ok && running {
			fmt.Printf("   ‚îú‚îÄ Status: üü¢ Active\n")
			fmt.Printf("   ‚îú‚îÄ Log Parser: %s:8082\n", baseURL)
			fmt.Printf("   ‚îú‚îÄ Service API: %s:8083/logging/*\n", baseURL)
			fmt.Printf("   ‚îú‚îÄ Educational Mode: Enabled\n")
			if educationalMode, ok := loggingStatus["educational_mode"].(bool); ok && educationalMode {
				fmt.Printf("   ‚îú‚îÄ Protocol Parsing: 3GPP specifications enabled\n")
				fmt.Printf("   ‚îú‚îÄ Session Tracking: IMSI correlation active\n")
			}
			fmt.Printf("   ‚îî‚îÄ Loki Integration: %s\n", loggingStatus["loki_url"])
		} else {
			fmt.Printf("   ‚îî‚îÄ Status: üî¥ Inactive\n")
		}
	} else {
		fmt.Printf("   ‚îî‚îÄ Status: ‚ö†Ô∏è  Not initialized\n")
	}
	fmt.Printf("\n")

	fmt.Printf("üîß Quick Tests:\n")
	// Real Open5GS endpoints
	for componentName, endpoint := range endpoints {
		fmt.Printf("   curl %s  # %s real metrics\n", endpoint, strings.ToUpper(componentName))
	}
	// Infrastructure endpoints
	fmt.Printf("   curl %s:8080/container/metrics  # Container resources\n", baseURL)
	fmt.Printf("   curl %s:8081/health/metrics     # Component health\n", baseURL)

	// NEW: Logging endpoints
	if loggingService != nil {
		fmt.Printf("   curl %s:8082/health            # Log parser health\n", baseURL)
		fmt.Printf("   curl %s:8083/logging/status    # Logging service status\n", baseURL)
		fmt.Printf("   curl %s:8083/logging/configs   # Generated Promtail configs\n", baseURL)
	}

	if isRunningInDocker() {
		fmt.Printf("\nüê≥ Docker Integration:\n")
		fmt.Printf("   ‚Ä¢ Prometheus config: /etc/prometheus/configs/prometheus.yml\n")
		fmt.Printf("   ‚Ä¢ Promtail configs: Auto-generated and mounted\n")
		fmt.Printf("   ‚Ä¢ Auto-reload: Configuration updated automatically\n")
	}
	fmt.Printf("\n")

	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
}

// Enhanced display for discovery mode results
func displayDiscoveryResults(topology *discovery.NetworkTopology) {
	fmt.Printf("\nüéØ DISCOVERY ANALYSIS RESULTS\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

	fmt.Printf("üèóÔ∏è  Network Architecture Detected:\n")
	fmt.Printf("   ‚îú‚îÄ Deployment Type: %s\n", topology.Type)
	fmt.Printf("   ‚îú‚îÄ Total Components: %d\n", len(topology.Components))

	// Count by type and status
	runningCount := 0
	networkFunctions := 0
	supportingServices := 0

	for _, component := range topology.Components {
		if component.IsRunning {
			runningCount++
		}
		// Define all Open5GS network functions
		allNetworkFunctions := map[string]bool{
			// 4G Core Network Functions
			"mme":  true, // Mobility Management Entity
			"hss":  true, // Home Subscriber Server
			"pcrf": true, // Policy and Charging Rules Function
			"sgwc": true, // Serving Gateway Control Plane
			"sgwu": true, // Serving Gateway User Plane

			// 5G Core Network Functions
			"nrf":  true, // Network Repository Function
			"scp":  true, // Service Communication Proxy
			"amf":  true, // Access and Mobility Management Function
			"ausf": true, // Authentication Server Function
			"udm":  true, // Unified Data Management
			"udr":  true, // Unified Data Repository
			"pcf":  true, // Policy Control Function
			"nssf": true, // Network Slice Selection Function
			"bsf":  true, // Binding Support Function

			// Shared between 4G and 5G
			"smf": true, // Session Management Function
			"upf": true, // User Plane Function
		}

		componentName := strings.ToLower(component.Name)
		isNetworkFunction := false

		for nfType := range allNetworkFunctions {
			if strings.Contains(componentName, nfType) {
				networkFunctions++
				isNetworkFunction = true
				break
			}
		}

		if !isNetworkFunction {
			supportingServices++
		}

	}

	fmt.Printf("   ‚îú‚îÄ Running Components: %d\n", runningCount)
	fmt.Printf("   ‚îú‚îÄ Network Functions: %d (AMF, SMF, UPF, MME, etc.)\n", networkFunctions)
	fmt.Printf("   ‚îî‚îÄ Supporting Services: %d (MongoDB, WebUI, etc.)\n", supportingServices)

	// Metrics capabilities analysis
	realMetrics := 0
	containerMetrics := 0
	healthMetrics := 0
	logSources := 0

	functionsWithMetricsSupport := map[string]bool{
		"amf": true, "smf": true, "pcf": true, "upf": true, "mme": true, "pcrf": true,
	}

	for _, component := range topology.Components {
		if component.IsRunning {
			componentName := strings.ToLower(component.Name)

			// Count real metrics support
			for nfType := range functionsWithMetricsSupport {
				if strings.Contains(componentName, nfType) {
					realMetrics++
					break
				}
			}

			// Every running component supports container and health metrics
			containerMetrics++
			healthMetrics++

			// Count log sources (components that generate logs)
			if isLoggingComponent(componentName) {
				logSources++
			}
		}
	}

	fmt.Printf("\nüìä Monitoring Capabilities Identified:\n")
	fmt.Printf("   ‚îú‚îÄ Real Open5GS Metrics: %d components support native /metrics\n", realMetrics)
	fmt.Printf("   ‚îú‚îÄ Container Monitoring: %d containers available for resource tracking\n", containerMetrics)
	fmt.Printf("   ‚îú‚îÄ Health Monitoring: %d components configured for health checks\n", healthMetrics)
	fmt.Printf("   ‚îî‚îÄ Log Sources: %d components generate structured logs\n", logSources)

	fmt.Printf("\nüìÅ Generated Configuration Files:\n")
	fmt.Printf("   ‚îú‚îÄ prometheus_targets.yml ‚Üí Complete Prometheus scrape configuration\n")
	fmt.Printf("   ‚îú‚îÄ promtail/core/config.yml ‚Üí Core network log configuration\n")
	fmt.Printf("   ‚îú‚îÄ promtail/ran/config.yml ‚Üí RAN log configuration\n")
	fmt.Printf("   ‚îú‚îÄ topology.json ‚Üí Machine-readable topology data\n")
	fmt.Printf("   ‚îú‚îÄ educational_dashboard.md ‚Üí Student learning guide\n")
	fmt.Printf("   ‚îî‚îÄ logging_insights.json ‚Üí Protocol analysis insights\n")

	fmt.Printf("\nüéì Educational Value:\n")
	fmt.Printf("   ‚îú‚îÄ Students can examine the complete monitoring architecture\n")
	fmt.Printf("   ‚îú‚îÄ Understanding of industry-standard observability practices\n")
	fmt.Printf("   ‚îú‚îÄ Hands-on experience with Prometheus configuration\n")
	fmt.Printf("   ‚îú‚îÄ Protocol-aware log analysis with 3GPP specifications\n")
	fmt.Printf("   ‚îú‚îÄ Session flow tracking and troubleshooting workflows\n")
	fmt.Printf("   ‚îî‚îÄ Real-world telecom O&M workflows\n")

	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
}

// NEW: Helper function to identify logging components
func isLoggingComponent(componentName string) bool {
	loggingComponents := []string{"amf", "smf", "upf", "pcf", "mme", "hss", "pcrf", "sgw", "nrf", "udm", "udr", "ausf", "nssf", "bsf", "srs", "enb", "gnb", "ue"}

	for _, logComp := range loggingComponents {
		if strings.Contains(componentName, logComp) {
			return true
		}
	}
	return false
}

// Export topology and real metrics configuration files
func exportTopologyAndConfig(topology *discovery.NetworkTopology) {
	// Export topology
	if err := writeFile("topology.json", topologyToJSON(topology)); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to export topology: %v", err)
	} else {
		fmt.Printf("\nüìÑ Exported topology to: topology.json\n")
	}

	// Create real collector manager to generate Prometheus config
	collectorManager := metrics.NewRealCollectorManager()
	if err := collectorManager.InitializeCollectors(topology); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to initialize collectors for config generation: %v", err)
		return
	}

	// Generate and save Prometheus configuration for real Open5GS metrics
	prometheusConfig := collectorManager.GeneratePrometheusConfig()
	if err := writeFile("prometheus_real_open5gs.yml", prometheusConfig); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to write Prometheus config: %v", err)
	} else {
		fmt.Printf("üìÑ Generated Prometheus config: prometheus_real_open5gs.yml\n")
	}

	// Generate enhanced summary report focused on real metrics
	generateEnhancedSummaryReport(topology)
}

// Generate enhanced summary report with real metrics focus
func generateEnhancedSummaryReport(topology *discovery.NetworkTopology) {
	summary := fmt.Sprintf(`# O&M Module - Real Open5GS Metrics Summary
Generated: %s
Deployment Type: %s
Total Components: %d

## Real Open5GS Metrics Collection

This O&M module now fetches REAL metrics from actual Open5GS components.
No simulation - 100%% live telecommunications data!

### Supported Network Functions with Real Metrics
`, topology.FormattedTimestamp(), topology.Type, len(topology.Components))

	supportedCount := 0
	for name, component := range topology.Components {
		if component.IsRunning {
			supportedTypes := []string{"amf", "smf", "pcf", "upf", "mme", "pcrf"}
			for _, nfType := range supportedTypes {
				if containsNF(name, nfType) {
					collectorPort := getCollectorPort(nfType)
					summary += fmt.Sprintf(`
- **%s** (%s)
  - Open5GS Endpoint: http://%s:9091/metrics
  - O&M Module Endpoint: http://localhost:%s/metrics  
  - Health Check: http://localhost:%s/health
  - Educational Dashboard: http://localhost:%s/dashboard
  - Raw Data Debug: http://localhost:%s/debug/raw
`, name, component.IP, component.IP, collectorPort, collectorPort, collectorPort, collectorPort)
					supportedCount++
					break
				}
			}
		}
	}

	if supportedCount == 0 {
		summary += "\n‚ö†Ô∏è  **No supported Open5GS NFs found!**\n"
		summary += "Make sure Open5GS components are configured with metrics enabled.\n"
	}

	summary += `
### Quick Start Commands

1. **Start Real Metrics Collection:**
   ./om-module orchestrator

2. **Test Real Metrics:**
   curl http://localhost:9091/metrics  # AMF real metrics
   curl http://localhost:9092/metrics  # SMF real metrics
   curl http://localhost:9091/debug/raw  # Raw Open5GS AMF data

3. **Test Logging Service:**
   curl http://localhost:8082/health          # Log parser health
   curl http://localhost:8083/logging/status  # Logging service status

4. **Configure Prometheus:**
   prometheus --config.file=prometheus_real_open5gs.yml

5. **Monitor Health:**
   curl http://localhost:9091/health  # AMF health

### Real Metrics Examples

The system collects actual Open5GS metrics like:
- fivegs_amffunction_rm_reginitreq (AMF registration requests)
- pfcp_sessions_active (SMF PFCP sessions)  
- ues_active (Active user equipments)
- gtp2_sessions_active (GTP sessions)
- ran_ue (Connected RAN UEs)

### Logging Pipeline

The integrated logging system provides:
- Real-time log parsing with educational context
- Protocol-aware analysis (NAS, RRC, S1AP, NGAP)
- 3GPP specification references
- Session flow tracking with IMSI correlation
- Performance metrics extraction from logs
- Dynamic Promtail configuration generation

### Architecture

This O&M module fetches metrics from Open5GS components and re-exposes them with:
- Enhanced labeling for better organization
- Educational information for learning
- Health monitoring and status reporting
- Debug access to raw Open5GS data
- Structured log processing with Loki integration

**No simulation - Real telecommunications monitoring!** üöÄ
`

	if err := writeFile("real_metrics_summary.md", summary); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to write summary: %v", err)
	} else {
		fmt.Printf("üìÑ Generated enhanced summary: real_metrics_summary.md\n")
	}
}

// Display next steps for real Open5GS metrics setup
func printRealMetricsNextSteps() {
	fmt.Printf("\nüöÄ Next Steps for Real Open5GS Metrics\n")
	fmt.Printf("=====================================\n")

	if isRunningInDocker() {
		fmt.Printf("üê≥ Docker Environment Detected:\n")
		fmt.Printf("1. **Start complete stack:**\n")
		fmt.Printf("   docker-compose -f services.yml up\n\n")
		fmt.Printf("2. **Access Prometheus:**\n")
		fmt.Printf("   http://localhost:9090/targets\n\n")
		fmt.Printf("3. **Access Grafana:**\n")
		fmt.Printf("   http://localhost:3000 (admin/admin)\n\n")
		fmt.Printf("4. **Access Loki logs:**\n")
		fmt.Printf("   http://localhost:3100 (via Grafana)\n\n")
	} else {
		fmt.Printf("1. üé¨ **Start real metrics collection:**\n")
		fmt.Printf("   ./om-module orchestrator\n\n")
		fmt.Printf("2. üîç **Test individual endpoints:**\n")
		fmt.Printf("   curl http://localhost:9091/metrics  # AMF real metrics\n")
		fmt.Printf("   curl http://localhost:9092/metrics  # SMF real metrics\n")
		fmt.Printf("   curl http://localhost:9091/debug/raw  # Raw Open5GS AMF\n\n")
		fmt.Printf("3. üìù **Test logging service:**\n")
		fmt.Printf("   curl http://localhost:8082/health          # Log parser\n")
		fmt.Printf("   curl http://localhost:8083/logging/status  # Logging service\n\n")
		fmt.Printf("4. üìä **Configure Prometheus:**\n")
		fmt.Printf("   prometheus --config.file=prometheus_real_open5gs.yml\n\n")
	}

	fmt.Printf("5. üè• **Monitor health:**\n")
	fmt.Printf("   curl http://localhost:9091/health\n\n")
	fmt.Printf("6. üìö **Educational dashboards:**\n")
	fmt.Printf("   curl http://localhost:9091/dashboard\n")
	fmt.Printf("   curl http://localhost:8083/logging/dashboard\n\n")
	fmt.Printf("‚ö° **All endpoints fetch live data from Open5GS components!**\n")
	fmt.Printf("üìù **Logs are processed with educational context and 3GPP specs!**\n")
	fmt.Printf("üéØ **No simulation - 100%% real telecommunications metrics!**\n")
}

func printUsage() {
	fmt.Printf("\nüìñ USAGE INFORMATION\n")
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
	fmt.Printf("Usage: %s [mode] [options]\n\n", os.Args[0])

	fmt.Printf("üîç DISCOVERY MODE (default):\n")
	fmt.Printf("   %s discovery [env_file]\n", os.Args[0])
	fmt.Printf("   ‚Ä¢ Analyzes your network topology without starting collectors\n")
	fmt.Printf("   ‚Ä¢ Generates Prometheus configurations and documentation\n")
	fmt.Printf("   ‚Ä¢ Creates dynamic Promtail configurations for logging\n")
	fmt.Printf("   ‚Ä¢ Perfect for understanding your setup before monitoring\n")
	fmt.Printf("   ‚Ä¢ Outputs: config files, topology analysis, setup guides\n\n")

	fmt.Printf("üé¨ ORCHESTRATOR MODE:\n")
	fmt.Printf("   %s orchestrator [env_file]\n", os.Args[0])
	fmt.Printf("   ‚Ä¢ Starts live real-time metrics collection from all components\n")
	fmt.Printf("   ‚Ä¢ Provides HTTP endpoints for Prometheus scraping\n")
	fmt.Printf("   ‚Ä¢ Starts log parser for real-time log processing\n")
	fmt.Printf("   ‚Ä¢ Continuously monitors and adapts to topology changes\n")
	fmt.Printf("   ‚Ä¢ Use this when you want active monitoring and data collection\n\n")

	fmt.Printf("üêû DEBUG OPTIONS:\n")
	fmt.Printf("   %s [mode] --debug    # Enable detailed debugging output\n", os.Args[0])
	fmt.Printf("   Creates additional debug files for troubleshooting\n\n")

	fmt.Printf("üìÅ ENV FILE:\n")
	if isRunningInDocker() {
		fmt.Printf("   Docker mode: .env (container environment)\n")
	} else {
		fmt.Printf("   Default: ../env (Docker Compose environment)\n")
		fmt.Printf("   Custom: Specify path to your .env file\n")
	}
	fmt.Printf("\n")

	fmt.Printf("üí° EXAMPLES:\n")
	fmt.Printf("   %s discovery                    # Analyze topology\n", os.Args[0])
	fmt.Printf("   %s orchestrator                 # Start live monitoring\n", os.Args[0])
	if !isRunningInDocker() {
		fmt.Printf("   %s discovery /path/to/.env      # Custom env file\n", os.Args[0])
	}
	fmt.Printf("   %s orchestrator --debug         # Debug mode\n", os.Args[0])
	fmt.Printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
}

// Helper functions remain the same but with updated documentation

func printBanner() {
	fmt.Printf("\n")
	fmt.Printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n")
	fmt.Printf("‚ïë                    üì° 4G/5G Network O&M Module v2.0                           ‚ïë\n")
	fmt.Printf("‚ïë                   Real-Time Monitoring & Educational Platform                 ‚ïë\n")
	fmt.Printf("‚ïë                    üéì Industry-Grade Observability for Labs                   ‚ïë\n")
	if isRunningInDocker() {
		fmt.Printf("‚ïë                          üê≥ Docker Integration Mode                           ‚ïë\n")
	}
	fmt.Printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")
	fmt.Printf("\n")
}

// Utility functions (keeping existing implementations)
func containsNF(componentName, nfName string) bool {
	return strings.Contains(strings.ToLower(componentName), nfName)
}

func getCollectorPort(nfType string) string {
	ports := map[string]string{
		"amf": "9091", "smf": "9092", "pcf": "9093",
		"upf": "9094", "mme": "9095", "pcrf": "9096",
	}
	if port, exists := ports[nfType]; exists {
		return port
	}
	return "9091"
}

func writeFile(filename, content string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer func() {
		err = file.Close()
	}()

	_, err = file.WriteString(content)
	return err
}

func topologyToJSON(topology *discovery.NetworkTopology) string {
	jsonBytes, err := json.MarshalIndent(topology, "", "  ")
	if err != nil {
		return fmt.Sprintf(`{
      "error": "Failed to marshal topology: %s",
      "timestamp": "%s", 
      "component_count": %d
    }`, err.Error(), time.Now().Format("2006-01-02T15:04:05Z"), len(topology.Components))
	}
	return string(jsonBytes)
}

// Enhanced dashboard generation with log-based dashboards
func generateEnhancedDashboards(orchestrator *metrics.RealCollectorOrchestrator, topology *discovery.NetworkTopology, inDocker bool) error {
	log.Printf("üìä Generating enhanced Grafana dashboards with log integration...")

	// Generate existing dashboards
	if err := dashboards.GenerateGrafanaDashboards(orchestrator, topology, inDocker); err != nil {
		log.Printf("‚ö†Ô∏è Failed to generate standard dashboards: %v", err)
	} else {
		log.Printf("‚úÖ Generated standard Grafana dashboards")
	}

	// Generate log-based dashboards if logging service is available
	if loggingService != nil {
		if err := dashboards.EnhanceWithLogDashboards(topology, loggingService); err != nil {
			log.Printf("‚ö†Ô∏è Failed to generate log-based dashboards: %v", err)
		} else {

			log.Printf("‚úÖ Generated log-based educational dashboards")
		}
	} else {

		log.Printf("‚ö†Ô∏è Logging service not available - skipping log-based dashboards")
	}

	return nil
}
