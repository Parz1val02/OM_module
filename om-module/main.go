package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/Parz1val02/OM_module/discovery"
	"github.com/Parz1val02/OM_module/metrics"
)

func main() {
	// Parse command line arguments
	var envFile, mode string
	if len(os.Args) > 1 {
		mode = os.Args[1]
	}
	if len(os.Args) > 2 {
		envFile = os.Args[2]
	} else {
		envFile = "../.env" // Default path
	}

	// Check if env file exists
	if _, err := os.Stat(envFile); os.IsNotExist(err) {
		log.Printf("‚ö†Ô∏è  Environment file %s not found, using defaults", envFile)
	}

	// Initialize auto-discovery service
	discoveryService, err := discovery.NewAutoDiscoveryService(envFile)
	if err != nil {
		log.Fatalf("‚ùå Failed to initialize discovery service: %v", err)
	}
	defer func() {
		if closeErr := discoveryService.Close(); closeErr != nil {
			log.Printf("Warning: Failed to close discovery service: %v", closeErr)
		}
	}()

	// Create context with signal handling
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle shutdown signals
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		log.Printf("üìù Received shutdown signal, stopping...")
		cancel()
	}()

	// Check mode
	switch mode {
	case "orchestrator", "metrics":
		runMetricsOrchestrator(ctx, discoveryService)
	case "discovery", "":
		runDiscoveryMode(ctx, discoveryService)
	default:
		log.Printf("‚ùå Unknown mode: %s", mode)
		printUsage()
		os.Exit(1)
	}
}

// runMetricsOrchestrator runs the continuous metrics orchestration mode
func runMetricsOrchestrator(ctx context.Context, discoveryService *discovery.AutoDiscoveryService) {
	printBanner()
	fmt.Printf("üîÑ Starting O&M Module in Enhanced Metrics Orchestrator mode...\n\n")

	// Initialize UPDATED metrics orchestrator (THIS IS THE KEY CHANGE)
	prometheusConfigPath := "./metrics/prometheus.yml"
	orchestrator, err := metrics.NewUpdatedMetricsOrchestrator(discoveryService, prometheusConfigPath)
	if err != nil {
		log.Fatalf("‚ùå Failed to initialize updated metrics orchestrator: %v", err)
	}

	// Initial discovery to show current state
	fmt.Printf("üîç Performing initial topology discovery...\n")
	topology, err := discoveryService.DiscoverTopology(ctx)
	if err != nil {
		log.Fatalf("‚ùå Failed to discover topology: %v", err)
	}

	displayTopologyResults(topology)

	// Show initial health status
	fmt.Printf("üè• Checking component health...\n")
	healthStatus, err := discoveryService.GetHealthStatus(ctx)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Failed to get health status: %v", err)
	} else {
		displayHealthStatus(healthStatus)
	}

	fmt.Printf("\n%s\n", strings.Repeat("=", 80))
	fmt.Printf("üöÄ Starting enhanced metrics orchestration with official collectors...\n")
	fmt.Printf("üìä Monitoring topology changes and updating Prometheus configuration\n")
	fmt.Printf("üìà Container metrics server will start on port 8080\n")
	fmt.Printf("üè• Health check server will start on port 8081\n")

	// NEW: Show official collector information
	fmt.Printf("üîß Official Network Function Collectors:\n")
	fmt.Printf("   üì° AMF Collector:  http://localhost:9091/metrics\n")
	fmt.Printf("   üì° SMF Collector:  http://localhost:9092/metrics\n")
	fmt.Printf("   üì° PCF Collector:  http://localhost:9093/metrics\n")
	fmt.Printf("   üì° UPF Collector:  http://localhost:9094/metrics\n")
	fmt.Printf("   üì° MME Collector:  http://localhost:9095/metrics\n")
	fmt.Printf("   üì° PCRF Collector: http://localhost:9096/metrics\n")

	fmt.Printf("üîÑ Press Ctrl+C to stop\n")
	fmt.Printf("%s\n\n", strings.Repeat("=", 80))

	// Start orchestrator (this will run continuously until context is cancelled)
	if err := orchestrator.Start(ctx); err != nil && err != context.Canceled {
		log.Fatalf("‚ùå Enhanced Orchestrator failed: %v", err)
	}

	fmt.Printf("\n‚úÖ Enhanced Metrics Orchestrator stopped gracefully\n")
}

// runDiscoveryMode runs the one-time discovery mode (original behavior) - UNCHANGED
func runDiscoveryMode(ctx context.Context, discoveryService *discovery.AutoDiscoveryService) {
	// Create context with timeout for operations
	timeoutCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// Display banner
	printBanner()

	// Perform discovery with error handling
	fmt.Printf("üîç Discovering network topology...\n")
	topology, err := discoveryService.DiscoverTopology(timeoutCtx)
	if err != nil {
		log.Fatalf("‚ùå Failed to discover topology: %v", err)
	}

	// Display discovery results
	displayTopologyResults(topology)

	// Display health status
	fmt.Printf("üè• Checking component health...\n")
	healthStatus, err := discoveryService.GetHealthStatus(timeoutCtx)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Failed to get health status: %v", err)
	} else {
		displayHealthStatus(healthStatus)
	}

	// List active components
	fmt.Printf("üìã Active components:\n")
	activeComponents, err := discoveryService.ListActiveComponents(timeoutCtx)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Failed to list active components: %v", err)
	} else {
		for i, component := range activeComponents {
			fmt.Printf("   %d. %s\n", i+1, component)
		}
	}

	// Display educational insights
	printEducationalInsights(topology)

	// Export topology data
	exportTopologyData(topology)

	// NEW: Display enhanced collector information
	printEnhancedCollectorInfo()

	// Show next steps
	printNextSteps()
}

// NEW: Enhanced collector information display
func printEnhancedCollectorInfo() {
	fmt.Printf("\nüîß Enhanced O&M Module Features:\n")
	fmt.Printf("================================\n")
	fmt.Printf("üìä Official Network Function Collectors:\n")
	fmt.Printf("   ‚Ä¢ AMF Metrics:  http://localhost:9091/metrics\n")
	fmt.Printf("   ‚Ä¢ SMF Metrics:  http://localhost:9092/metrics\n")
	fmt.Printf("   ‚Ä¢ PCF Metrics:  http://localhost:9093/metrics\n")
	fmt.Printf("   ‚Ä¢ UPF Metrics:  http://localhost:9094/metrics\n")
	fmt.Printf("   ‚Ä¢ MME Metrics:  http://localhost:9095/metrics\n")
	fmt.Printf("   ‚Ä¢ PCRF Metrics: http://localhost:9096/metrics\n")
	fmt.Printf("\nüìö Educational Dashboards:\n")
	fmt.Printf("   ‚Ä¢ AMF Dashboard:  http://localhost:9091/dashboard\n")
	fmt.Printf("   ‚Ä¢ SMF Dashboard:  http://localhost:9092/dashboard\n")
	fmt.Printf("   ‚Ä¢ PCF Dashboard:  http://localhost:9093/dashboard\n")
	fmt.Printf("   ‚Ä¢ UPF Dashboard:  http://localhost:9094/dashboard\n")
	fmt.Printf("   ‚Ä¢ MME Dashboard:  http://localhost:9095/dashboard\n")
	fmt.Printf("   ‚Ä¢ PCRF Dashboard: http://localhost:9096/dashboard\n")
	fmt.Printf("\nüè• Health Check Endpoints:\n")
	fmt.Printf("   ‚Ä¢ Component Health: http://localhost:8081/health/status\n")
	fmt.Printf("   ‚Ä¢ Health Metrics:   http://localhost:8081/health/metrics\n")
	fmt.Printf("\nüìà Container Metrics:\n")
	fmt.Printf("   ‚Ä¢ Container Stats:  http://localhost:8080/container/metrics\n")
	fmt.Printf("   ‚Ä¢ Container Health: http://localhost:8080/health\n")
}

// printBanner displays the application banner - UNCHANGED
func printBanner() {
	fmt.Printf("\n")
	fmt.Printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n")
	fmt.Printf("‚ïë                    üì° 5G/4G Core Network O&M Module                          ‚ïë\n")
	fmt.Printf("‚ïë                         Enhanced with Official Collectors                     ‚ïë\n")
	fmt.Printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")
	fmt.Printf("\n")
}

// UNCHANGED functions (keeping existing implementations)
func displayTopologyResults(topology *discovery.NetworkTopology) {
	fmt.Printf("\nüåê Network Topology Discovered:\n")
	fmt.Printf("===============================\n")
	fmt.Printf("Deployment Type: %s\n", topology.Type)
	fmt.Printf("Total Components: %d\n", len(topology.Components))
	fmt.Printf("Timestamp: %s\n\n", time.Unix(topology.Timestamp, 0).Format("2006-01-02 15:04:05"))

	// Group components by type for better display
	groupedComponents := groupComponentsByType(topology.Components)

	for componentType, components := range groupedComponents {
		fmt.Printf("üì¶ %s Components:\n", componentType)
		for _, component := range components {
			status := "üî¥ Down"
			if component.IsRunning {
				status = "üü¢ Running"
			}
			fmt.Printf("  ‚Ä¢ %s (%s) - %s [%s]\n", component.Name, component.IP, status, strings.Join(component.Ports, ", "))
		}
		fmt.Println()
	}
}

func displayHealthStatus(healthStatus map[string]string) {
	fmt.Printf("üè• Component Health Status:\n")
	fmt.Printf("==========================\n")

	healthCounts := make(map[string]int)

	for component, status := range healthStatus {
		emoji := getHealthEmoji(status)
		fmt.Printf("  %s %s: %s\n", emoji, component, status)
		healthCounts[status]++
	}

	fmt.Printf("\nüìä Health Summary:\n")
	for status, count := range healthCounts {
		emoji := getHealthEmoji(status)
		fmt.Printf("  %s %s: %d components\n", emoji, status, count)
	}
	fmt.Println()
}

func groupComponentsByType(components map[string]discovery.Component) map[string][]discovery.Component {
	groups := make(map[string][]discovery.Component)

	for _, component := range components {
		groups[component.Type] = append(groups[component.Type], component)
	}

	return groups
}

func printEducationalInsights(topology *discovery.NetworkTopology) {
	fmt.Printf("üéì Educational Insights:\n")
	fmt.Printf("========================\n")

	switch topology.Type {
	case discovery.TYPE_4G:
		fmt.Printf("üìö This is a 4G EPC (Evolved Packet Core) deployment\n")
		fmt.Printf("   ‚Ä¢ Key components: MME (Mobility Management), HSS (Subscriber Database)\n")
		fmt.Printf("   ‚Ä¢ Architecture: Control and User plane separated (CUPS)\n")
		fmt.Printf("   ‚Ä¢ Interfaces: S1, S6a, S11, S5/S8, SGi\n")
		fmt.Printf("   ‚Ä¢ NEW: Official metrics available for MME, PCRF, SMF, UPF\n")

	case discovery.TYPE_5G:
		fmt.Printf("üìö This is a 5G Core (5GC) Service Based Architecture deployment\n")
		fmt.Printf("   ‚Ä¢ Key components: AMF (Access & Mobility), SMF (Session Management)\n")
		fmt.Printf("   ‚Ä¢ Architecture: Microservices with Service Based Interfaces (SBI)\n")
		fmt.Printf("   ‚Ä¢ Interfaces: N1, N2, N3, N4, N6, Nnrf, Namf, Nsmf\n")
		fmt.Printf("   ‚Ä¢ NEW: Official metrics available for AMF, SMF, PCF, UPF\n")

	case discovery.TYPE_MIXED:
		fmt.Printf("üìö This is a Mixed 4G/5G deployment (Non-Standalone)\n")
		fmt.Printf("   ‚Ä¢ Hybrid architecture with both EPC and 5GC components\n")
		fmt.Printf("   ‚Ä¢ Enables migration scenarios and interoperability testing\n")
		fmt.Printf("   ‚Ä¢ NEW: Full metrics coverage for both 4G and 5G components\n")
	}

	fmt.Printf("\nüîß Enhanced O&M Capabilities:\n")
	fmt.Printf("   ‚Ä¢ Real-time KPI monitoring\n")
	fmt.Printf("   ‚Ä¢ Industry-standard metrics exposition\n")
	fmt.Printf("   ‚Ä¢ Educational dashboards with explanations\n")
	fmt.Printf("   ‚Ä¢ Health checking and alerting\n")
	fmt.Printf("   ‚Ä¢ Performance analysis tools\n")
	fmt.Println()
}

func exportTopologyData(topology *discovery.NetworkTopology) {
	// Export as JSON
	jsonData, err := json.MarshalIndent(topology, "", "  ")
	if err != nil {
		log.Printf("‚ö†Ô∏è  Failed to marshal topology to JSON: %v", err)
	} else {
		if err := os.WriteFile("topology.json", jsonData, 0644); err != nil {
			log.Printf("‚ö†Ô∏è  Failed to write topology.json: %v", err)
		} else {
			fmt.Printf("üìÑ Exported topology data to topology.json\n")
		}
	}
}

func getHealthEmoji(status string) string {
	switch strings.ToLower(status) {
	case "healthy", "up", "running":
		return "üü¢"
	case "unhealthy", "down", "stopped":
		return "üî¥"
	case "degraded", "warning":
		return "üü°"
	default:
		return "‚ö™"
	}
}

func printUsage() {
	fmt.Printf("Usage: %s [mode] [env_file]\n", os.Args[0])
	fmt.Printf("Modes:\n")
	fmt.Printf("  discovery    - One-time discovery (default)\n")
	fmt.Printf("  orchestrator - Continuous metrics orchestration\n")
	fmt.Printf("  metrics      - Alias for orchestrator\n")
	fmt.Printf("\nEnv file: Path to .env file (default: ../.env)\n")
}

// UPDATED: Enhanced next steps with new collector information
func printNextSteps() {
	fmt.Printf("\nüöÄ Next Steps:\n")
	fmt.Printf("==============\n")
	fmt.Printf("1. üîÑ Run continuous monitoring: %s orchestrator\n", os.Args[0])
	fmt.Printf("\n2. üìä Access enhanced metrics:\n")
	fmt.Printf("   ‚Ä¢ Official NF metrics: http://localhost:909[1-6]/metrics\n")
	fmt.Printf("   ‚Ä¢ Container metrics:    http://localhost:8080/container/metrics\n")
	fmt.Printf("   ‚Ä¢ Health check metrics: http://localhost:8081/health/metrics\n")
	fmt.Printf("\n3. üìö Educational dashboards:\n")
	fmt.Printf("   ‚Ä¢ NF dashboards: http://localhost:909[1-6]/dashboard\n")
	fmt.Printf("   ‚Ä¢ Component health: http://localhost:8081/health/status\n")
	fmt.Printf("\n4. üìà Start Prometheus monitoring:\n")
	fmt.Printf("   ‚Ä¢ Use generated prometheus.yml configuration\n")
	fmt.Printf("   ‚Ä¢ Check Prometheus: http://<DOCKER_HOST_IP>:9090\n")
	fmt.Printf("\n5. üîß Test all endpoints:\n")
	fmt.Printf("   ‚Ä¢ Run: curl http://localhost:9091/health (AMF)\n")
	fmt.Printf("   ‚Ä¢ Run: curl http://localhost:9092/metrics (SMF)\n")
	fmt.Printf("   ‚Ä¢ Run: curl http://localhost:8080/container/metrics\n")
	fmt.Printf("\n6. üîÑ Monitor in real-time: %s orchestrator\n", os.Args[0])
	fmt.Printf("7. üìù Monitor logs: docker-compose logs -f <component_name>\n")
}
